\section{Introduction}
\label{sec:introduction}

Partial Reconfiguration (PR) is a technique which allows portions of a field-programmable gate array (FPGA) to be dynamically reconfigured after the complete device has been initially configured.
This allows the circuit's functionality to be customized on the fly, such as in response to changing operating conditions or user directives.
In the most common form, a PR design includes a static region and one or more PR regions into which pre-compiled circuits can be configured at run-time.
The static region contains common and unchanging functionality such as external I/O interfaces, clocking, and other base system functionality.
The PR regions reserve logic for functions which can change dynamically, such as accelerator cores.
As FPGA sizes continue to grow we believe the use of PR will become increasingly important.

Xilinx provides a PR design flow for their FPGA devices \cite{Xilinx:2018d}.
In a basic form of this flow, a base static design is created by the user and a specific module is identified to be partially reconfigurable; this module is known as a reconfigurable module (RM). 
For this RM, a physical PR region (known as a reconfigurable partition in Vivado's PR flow) is identified, into which the RM's circuitry will be placed and routed.
The subsequent tool flow steps then implement the entire design while limiting the RM's circuitry to its defined region.
The result is a full-chip bitstream which can be configured onto the device. 
Later, other RMs can be compiled into the same PR region, resulting in partial bitstreams which can be dynamically reconfigured onto the PR region.

To compile these RMs requires the availability of the original PR project files as well as the full Vivado design suite, no matter how small the RM.
A full Xilinx Vivado 2018.2 installation requires over 50 GB of disk space to support the design of Xilinx FPGAs from several families.
A minimum of 48 GB of RAM is also required to compile designs to bitstreams for the largest devices \cite{Xilinx:2018}.
Additionally, Vivado can only be run on x86 or x86-64 machines \cite{Xilinx:2018b}.
These requirements limit the sizes and types of machines that PR designs can be developed on.

This work introduces a different model for creating PR designs in which the original design is created using Vivadoâ€™s PR flow, and subsequent RMs can then be created on-the-fly using lightweight tools, independent of Vivado.
By separating out the initial static design creation from later RM creation, a smaller portion of the FPGA fabric is targeted by the CAD tools, allowing them to run on systems with lower memory, storage, and compute requirements.
This paper describes Maverick, a Vivado-independent RM tool flow, which can be run on a variety of systems, including embedded systems.

The independent and lightweight nature of Maverick opens up a number of new usage models, not readily supported by the current vendor tools.
For example, this enables the creation of fully autonomous systems which are untethered from other compute resources.
In this model, adaptation algorithms running on an autonomous platform could create new HDL design code for an RM (or modify existing RM HDL code) which would then be compiled by the Maverick flow and configured onto the platform's FPGA fabric.
Such autonomous systems could use this model to provide domain specific functionality or to improve fault tolerance.
Another potential usage model is a customized system tailored for education, which could mix instructional materials, sample designs, HDL code, and CAD tools into a lightweight stand-alone hardware platform.
This would enable the creation of a set of specialized visualization and analysis tools for learning on top of that system.

This paper demonstrates the Maverick flow executing on the embedded PYNQ-Z1 board, which contains a Zynq 7020 system on chip (SoC).
The Maverick CAD tools run on an ARM processor embedded within the processing system (PS) of the Zynq device.
This flow generates partial bitstreams which are configured onto a PR region within the programmable logic (PL) fabric of the same Zynq device.

Additionally, this paper reports on the results of several simple benchmark designs compiled on the PYNQ-Z1.
The execution time and memory requirements of the Maverick flow are measured for each design run.
The quality of results of the generated designs within Maverick is also compared against results from the same set of circuits generated by the commercial Vivado tools.
Although the Maverick design flow does not produce circuits with the same level of quality as the commercial tool flow, this paper demonstrates that it is possible to generate usable, operating circuit bitstreams within FPGA PR regions {\em without} the need of any commercial tools.
